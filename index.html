<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DayZ World Map — R2 (fake zoom out)</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height:100%; margin:0; padding:0; }
    .leaflet-container { background:#0b0f14; }
    #badge, #status, #hud {
      position:fixed; left:10px; z-index:9999;
      padding:6px 10px; border-radius:8px; color:#fff; font:14px system-ui, sans-serif;
      pointer-events:none;
    }
    #badge  { top:10px; background:#2e7d32; }
    #status { top:44px; background:#1565c0; max-width:80vw; white-space:pre-wrap; word-break:break-all; }
    #hud    { bottom:10px; background:rgba(0,0,0,.6); font:13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #hud b  { color:#8bc34a; }
    /* we’ll scale the tile/overlay panes, keep the map frame unscaled */
    .scaled { transform-origin: top left; will-change: transform; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="badge">R2 • fake extra-out=6 • view:<span id="viewname">t</span></div>
  <div id="status">booting…</div>
  <div id="hud">move mouse…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // ===== config =====
    const WORLD   = "world";
    const BUCKET  = 32;                // blocks per tile
    const VERSION = "r2-fakezoom-v1";
    const R2_BASE = "https://pub-5406e95e9e584f748be162ed018ae7fc.r2.dev/";

    // switch sets: t (iso 30° hires), flat, ct
    const qp = new URLSearchParams(location.search);
    const VIEW = (qp.get("view") || "t").trim();
    document.getElementById('viewname').textContent = VIEW;

    // your dynmap bounds (in blocks)
    const X_MIN_BLK = -2640, X_MAX_BLK = 2720;
    const Z_MIN_BLK = -2720, Z_MAX_BLK = 5536;

    // probe one known-good tile to learn ext + TILE size
    const START_X = -10, START_Y = -33;

    // derived file-tile bounds
    const MIN_X = Math.floor(X_MIN_BLK / BUCKET);
    const MAX_X = Math.ceil (X_MAX_BLK / BUCKET) - 1;
    const MIN_Y = Math.floor(Z_MIN_BLK / BUCKET);
    const MAX_Y = Math.ceil (Z_MAX_BLK / BUCKET) - 1;
    const widthTiles  = MAX_X - MIN_X + 1;
    const heightTiles = MAX_Y - MIN_Y + 1;

    const BLANK = 'data:image/gif;base64,R0lGODlhAQABAAAAACw=';

    // helpers
    function floorDiv(n, d){ if(n>=0) return Math.floor(n/d); const q=Math.trunc(n/d); return (q*d===n)?q:q-1; }
    const group     = (n) => floorDiv(n, BUCKET);
    const withSlash = (s) => s.endsWith('/') ? s : s + '/';

    const startFolder = `${group(START_X)}_${group(START_Y)}`;
    const startPath   = (ext) => `tiles/${WORLD}/${VIEW}/${startFolder}/${START_X}_${START_Y}.${ext}`;

    function probe(url, timeoutMs=6000){
      return new Promise((resolve)=>{
        const img = new Image();
        const t = setTimeout(()=>{img.src=''; resolve(false)}, timeoutMs);
        img.onload  = ()=>{ clearTimeout(t); resolve(true); };
        img.onerror = ()=>{ clearTimeout(t); resolve(false); };
        img.src = url + "?probe=" + VERSION;
      });
    }
    async function detectTileSize(url){
      return new Promise((resolve)=>{
        const img=new Image();
        img.onload=()=>resolve(img.naturalWidth||128);
        img.onerror=()=>resolve(128);
        img.src=url + "?size=" + VERSION;
      });
    }
    async function resolveSource(){
      const status = (m,c='#1565c0')=>{const el=document.getElementById('status'); el.textContent=m; el.style.background=c;};
      const base = withSlash(R2_BASE);
      for (const ext of ['png','jpg','jpeg']){
        const url = base + startPath(ext);
        status(`probing:\n${url}`);
        // eslint-disable-next-line no-await-in-loop
        if (await probe(url)){
          const TILE = await detectTileSize(url);
          status(`OK → base: ${base}\nview: ${VIEW} • ext: .${ext} • tile: ${TILE}px`, '#2e7d32');
          return { BASE: base, EXT: ext, TILE };
        }
      }
      const el=document.getElementById('status');
      el.textContent = `No start tile at:\n${base}${startPath('png')}\nCheck public access and /tiles/${WORLD}/${VIEW}/...`;
      el.style.background = '#b71c1c';
      throw new Error('Could not resolve tiles');
    }

    (async () => {
      const { BASE, EXT, TILE } = await resolveSource();

      // Leaflet map locked at zoom 0 (no tile pyramid)
      const map = L.map('map', {
        crs: L.CRS.Simple,
        zoomControl: false,
        zoomSnap: 0, // we'll ignore Leaflet's zoom pipeline
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        touchZoom: false,
        inertia: true, // normal panning ok
      });

      // Our tile layer always targets z0 tile grid (no zoom param)
      const DynmapZ0 = L.TileLayer.extend({
        getTileUrl: function (coords) {
          // coords.x/y are the current z0 tile indices (because we won't change map zoom)
          const fx = MIN_X + coords.x;
          const fy = MAX_Y - coords.y; // flip Y
          if (fx < MIN_X || fx > MAX_X || fy < MIN_Y || fy > MAX_Y) return BLANK;
          const gx = group(fx), gy = group(fy);
          return `${BASE}tiles/${WORLD}/${VIEW}/${gx}_${gy}/${fx}_${fy}.${EXT}?${VERSION}`;
        }
      });

      const layer = new DynmapZ0('', {
        tileSize: TILE,
        noWrap: true,
        keepBuffer: 8, // keep a wider ring when we scale
        updateWhenZooming: false,
        updateWhenIdle: true
      }).addTo(map);

      // world bounds & initial fit
      const bounds = [[-(heightTiles*TILE), 0], [0, widthTiles*TILE]];
      map.setMaxBounds(bounds);
      map.options.maxBoundsViscosity = 1.0;
      // Fit by setting an artificial pixel world and center
      const startLatLngBounds = L.latLngBounds(bounds).pad(0.12);
      map.fitBounds(startLatLngBounds);

      // mark panes to scale
      const panes = [
        map.getPane('tilePane'),
        map.getPane('overlayPane'),
        map.getPane('shadowPane')
      ];
      panes.forEach(p => p.classList.add('scaled'));

      // ---- FAKE ZOOM STATE ----
      let scale = 1;                // 1 = native; each wheel notch halves/doubles
      const MIN_SCALE = 1 / 64;     // ~6 extra zoom-outs
      const MAX_SCALE = 4;          // allow some zoom-in

      function applyScale() {
        const s = `scale(${scale})`;
        panes.forEach(p => p.style.transform = s);
        // keep the map panning feel consistent by adjusting tile loading margin
        layer.options.keepBuffer = scale < 1 ? 12 : 8;
      }

      // intercept wheel to change *visual* scale (not Leaflet zoom)
      map.getContainer().addEventListener('wheel', (ev) => {
        ev.preventDefault();
        const dir = ev.deltaY > 0 ? -1 : 1; // down = zoom out
        scale *= (dir > 0 ? 2 : 0.5);
        if (scale < MIN_SCALE) scale = MIN_SCALE;
        if (scale > MAX_SCALE) scale = MAX_SCALE;
        applyScale();
        status(`fake zoom: ×${scale.toFixed(3)} (using z0 tiles only)`, '#2e7d32');
      }, { passive: false });

      // HUD + status
      const statusEl = document.getElementById('status');
      const hud = document.getElementById('hud');
      const status = (msg, color='#1565c0') => { statusEl.textContent = msg; statusEl.style.background = color; };
      L.TileLayer.prototype.options.errorTileUrl = BLANK;
      layer.on('tileerror', e => console.warn('404 tile inside range:', e.tile.src));

      // continuous coords (account for visual scale)
      const PPB = TILE / BUCKET; // pixels/block at native scale
      function updateHUD(latlng){
        // get pixel point at Leaflet's fixed zoom (z0), then unscale
        const p = map.project(latlng, 0); // z0 pixels
        const px0 = p.x / scale;
        const py0 = p.y / scale;

        const Xf = (px0 / PPB) + (MIN_X * BUCKET);
        const Zf = (py0 / PPB) + (MIN_Y * BUCKET);

        const lx = Math.floor(px0 / TILE);
        const ly = Math.floor(py0 / TILE);
        const fx = MIN_X + lx;
        const fy = MAX_Y - ly;
        const gx = group(fx), gy = group(fy);

        hud.innerHTML =
          `X:<b>${Xf.toFixed(1)}</b>  Z:<b>${Zf.toFixed(1)}</b>  |  tile:<b>${fx}_${fy}</b>  bucket:<b>${gx}_${gy}</b>` +
          `  | fake-zoom ×${scale.toFixed(3)}`;
        return { Xf, Zf, fx, fy, gx, gy };
      }
      map.on('mousemove', e => updateHUD(e.latlng));
      map.on('click', e => {
        const info = updateHUD(e.latlng);
        navigator.clipboard?.writeText(`${Math.floor(info.Xf)} ${Math.floor(info.Zf)}`);
        const url = `${withSlash(R2_BASE)}tiles/${WORLD}/${VIEW}/${info.gx}_${info.gy}/${info.fx}_${info.fy}.${EXT}`;
        status(`copied coords • ${Math.floor(info.Xf)} ${Math.floor(info.Zf)}\n${url}`, '#2e7d32');
      });

      status('Ready. Use mouse wheel to fake-zoom (no extra pyramid needed).');
      applyScale();
    })();
  </script>
</body>
</html>
