<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DayZ World Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- disable caching while testing -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height:100%; margin:0; padding:0; }
    .leaflet-container { background:#0b0f14; }

    #hud, #status {
      position: fixed;
      left: 10px;
      z-index: 9999;
      padding: 6px 10px;
      border-radius: 8px;
      color: #fff;
      font: 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      pointer-events: none;
      background: rgba(0,0,0,.6);
      max-width: 85vw;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #status { top: 10px; font: 14px system-ui, sans-serif; background:#1565c0; }
    #hud { bottom: 10px; }
    #hud b { color:#8bc34a; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="status">booting…</div>
  <div id="hud">loading…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
  /* ================= CONFIG ================= */

  const WORLD   = "world";
  const VIEW    = "ne"; // dynmap prefix folder under tiles/world/
  const BASE_URL = "https://pub-83eb0b1759804463a95053e4b8319ef5.r2.dev/"; // must end with /

  // Dynmap base grid:
  const BLOCKS_PER_TILE = 32;   // your z0: tile covers 32x32 blocks
  const TILES_PER_DIR   = 32;   // bucket folder size

  // Your rendered bounds (blocks) - from your dynmap visibilitylimits
  const X_MIN = -2640, X_MAX = 2720;
  const Z_MIN = -2720, Z_MAX = 5536;

  // You said you have 6 zoom-outs, so Leaflet minZoom should be -6
  const MIN_ZOOM   = -6;
  const MAX_ZOOM   =  2;
  const START_ZOOM = -6;

  const BLANK = "data:image/gif;base64,R0lGODlhAQABAAAAACw=";

  /* ================= HELPERS ================= */

  function withSlash(s){ return s.endsWith("/") ? s : (s + "/"); }
  const BASE = withSlash(BASE_URL);

  // floor division that behaves for negatives the way dynmap tiling expects
  function floorDiv(n, d){
    if (n >= 0) return Math.floor(n / d);
    const q = Math.trunc(n / d);
    return (q * d === n) ? q : (q - 1);
  }

  function bucketIndex(t){ return floorDiv(t, TILES_PER_DIR); }

  function zoomOutFromLeafletZ(z){
    // Leaflet z: 0 is native, -1 is 1 zoom out, ...
    return Math.max(0, -z);
  }

  function dynPrefix(zoomOut){
    return zoomOut <= 0 ? "" : ("z".repeat(zoomOut) + "_");
  }

  // Given a zoomOut, compute dynmap tile index bounds for your block bounds.
  function tileBoundsForZoomOut(zoomOut){
    const blocksPerTile = BLOCKS_PER_TILE * (1 << zoomOut);

    const minTX = floorDiv(X_MIN, blocksPerTile);
    const maxTX = floorDiv(X_MAX - 1, blocksPerTile);
    const minTY = floorDiv(Z_MIN, blocksPerTile);
    const maxTY = floorDiv(Z_MAX - 1, blocksPerTile);

    return { minTX, maxTX, minTY, maxTY, blocksPerTile };
  }

  function tilePath(ext, zoomOut, tx, ty){
    const bx = bucketIndex(tx);
    const by = bucketIndex(ty);
    const pref = dynPrefix(zoomOut);
    // matches your files: world/ne/<bx>_<by>/<pref><tx>_<ty>.jpg
    return `tiles/${WORLD}/${VIEW}/${bx}_${by}/${pref}${tx}_${ty}.${ext}`;
  }

  function probe(url, timeoutMs=6000){
    return new Promise((resolve)=>{
      const img = new Image();
      const t = setTimeout(()=>{ img.src=""; resolve(false); }, timeoutMs);
      img.onload  = ()=>{ clearTimeout(t); resolve(true); };
      img.onerror = ()=>{ clearTimeout(t); resolve(false); };
      img.src = url + (url.includes("?") ? "&" : "?") + "p=" + Date.now();
    });
  }

  async function detect(){
    const statusEl = document.getElementById("status");
    const status = (m, color="#1565c0") => { statusEl.textContent = m; statusEl.style.background = color; };

    // probe near-ish center (blocks)
    const probeX = -16, probeZ = -16;

    for (const ext of ["jpg","png","jpeg"]) {
      // try zoomOut 0 probe
      const zb = tileBoundsForZoomOut(0);
      const pTX = floorDiv(probeX, zb.blocksPerTile);
      const pTY = floorDiv(probeZ, zb.blocksPerTile);

      const url = BASE + tilePath(ext, 0, pTX, pTY);
      status(`probing:\n${url}`);

      // eslint-disable-next-line no-await-in-loop
      if (await probe(url)) {
        const TILE_PX = await new Promise((resolve)=>{
          const img = new Image();
          img.onload = ()=> resolve(img.naturalWidth || 128);
          img.onerror = ()=> resolve(128);
          img.src = url + "&s=" + Date.now();
        });

        status(`OK\nworld:${WORLD}\nview:${VIEW}\next:${ext}\ntile:${TILE_PX}px`, "#2e7d32");
        return { EXT: ext, TILE_PX };
      }
    }

    document.getElementById("status").textContent =
      `FAILED: couldn't find base tiles. Check BASE_URL, bucket public read, and path tiles/${WORLD}/${VIEW}/...`;
    throw new Error("No tiles found");
  }

  (async () => {
    const { EXT, TILE_PX } = await detect();

    // Build z0 pixel bounds (Leaflet CRS.Simple uses "pixels at zoom 0" units)
    const z0 = tileBoundsForZoomOut(0);
    const W0 = (z0.maxTX - z0.minTX + 1);
    const H0 = (z0.maxTY - z0.minTY + 1);

    const z0Bounds = L.latLngBounds(
      [-(H0 * TILE_PX), 0],
      [0, (W0 * TILE_PX)]
    );

    const map = L.map("map", {
      crs: L.CRS.Simple,
      minZoom: MIN_ZOOM,
      maxZoom: MAX_ZOOM,
      zoomSnap: 1,
      updateWhenZooming: false,
      zoomControl: true
    });

    // IMPORTANT: do NOT hard clamp maxBounds here, it feels “cut off” when zoomed out.
    // If you want *some* constraint, uncomment this and use a padded bounds:
    // map.setMaxBounds(z0Bounds.pad(1.0));
    // map.options.maxBoundsViscosity = 0.8;

    // Grid layer that maps Leaflet z -> Dynmap zoomOut tile naming + coordinate grid
    const DynGrid = L.GridLayer.extend({
      createTile: function(coords){
        const tile = document.createElement("img");
        tile.alt = "";
        tile.setAttribute("role","presentation");
        tile.width = TILE_PX;
        tile.height = TILE_PX;

        const z = coords.z;
        const zoomOut = zoomOutFromLeafletZ(z);

        const b = tileBoundsForZoomOut(zoomOut);

        // Our map origin is the z0 bounds origin.
        // At each zoomOut, Leaflet's coords.x/coords.y are in that zoom's tile grid size.
        const tx = b.minTX + coords.x;
        const ty = b.maxTY - coords.y; // flip Y (matches earlier working z0)

        // If outside rendered bounds for this zoomOut, return blank
        if (tx < b.minTX || tx > b.maxTX || ty < b.minTY || ty > b.maxTY) {
          tile.src = BLANK;
          return tile;
        }

        tile.src = BASE + tilePath(EXT, zoomOut, tx, ty) + "?v=1";

        tile.onerror = () => { tile.src = BLANK; };
        return tile;
      }
    });

    DynGrid.prototype.getTileSize = function(){ return L.point(TILE_PX, TILE_PX); };

    const layer = new DynGrid({
      tileSize: TILE_PX,
      noWrap: true,
      keepBuffer: 10,
      updateWhenZooming: false,
      updateWhenIdle: true
    });

    layer.addTo(map);

    // Start centered on rendered area and start at 6 zoom-outs
    map.fitBounds(z0Bounds.pad(0.12));
    map.setZoom(START_ZOOM);

    // HUD: show block coords + which dyn zoomOut tile we're on
    const hud = document.getElementById("hud");
    const pxPerBlockZ0 = TILE_PX / BLOCKS_PER_TILE; // z0 pixels per block

    function updateHUD(latlng){
      const z = map.getZoom();
      const zoomOut = zoomOutFromLeafletZ(z);

      // Project at current zoom, then normalize back to z0 pixel space
      const p = map.project(latlng, z);
      const px0 = p.x * Math.pow(2, -z);
      const py0 = p.y * Math.pow(2, -z);

      const X = (px0 / pxPerBlockZ0) + (z0.minTX * BLOCKS_PER_TILE);
      const Z = (py0 / pxPerBlockZ0) + (z0.minTY * BLOCKS_PER_TILE);

      const b = tileBoundsForZoomOut(zoomOut);

      // tile coords at this zoomOut (roughly)
      const tx = b.minTX + Math.floor((px0 / TILE_PX) / (1 << zoomOut));
      const ty = b.maxTY - Math.floor((py0 / TILE_PX) / (1 << zoomOut));

      hud.innerHTML =
        `X:<b>${X.toFixed(1)}</b> Z:<b>${Z.toFixed(1)}</b>` +
        ` | z=<b>${z}</b> zoomOut:<b>${zoomOut}</b> (${dynPrefix(zoomOut) || "base"})` +
        ` | tile:<b>${tx}_${ty}</b>`;

      return { X, Z };
    }

    map.on("mousemove", e => updateHUD(e.latlng));
    map.on("click", e => {
      const { X, Z } = updateHUD(e.latlng);
      navigator.clipboard?.writeText(`${Math.floor(X)} ${Math.floor(Z)}`);
    });

    console.log("Viewer ready", { WORLD, VIEW, EXT, TILE_PX });
  })();
  </script>
</body>
</html>
