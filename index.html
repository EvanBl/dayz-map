<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DayZ World Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- disable caching while testing -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height:100%; margin:0; padding:0; }
    .leaflet-container { background:#0b0f14; }

    #hud, #status {
      position: fixed;
      left: 10px;
      z-index: 9999;
      padding: 6px 10px;
      border-radius: 8px;
      color: #fff;
      font: 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      pointer-events: none;
      background: rgba(0,0,0,.6);
      max-width: 85vw;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #status { top: 10px; font: 14px system-ui, sans-serif; background:#1565c0; }
    #hud { bottom: 10px; }
    #hud b { color:#8bc34a; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="status">booting…</div>
  <div id="hud">loading…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
  /* ================= CONFIG ================= */

  const WORLD = "world";
  const VIEW  = "ne"; // dynmap prefix folder under tiles/world/
  const BASE_URL = "https://pub-83eb0b1759804463a95053e4b8319ef5.r2.dev/";

  // Dynmap rules for your install (from your filenames)
  const BASE_BLOCKS_PER_TILE = 32;   // zoomOut 0 tile = 32x32 blocks
  const TILES_PER_DIR        = 32;   // bucket folders are 32x32 tiles

  // Leaflet zoom config:
  // zoomOut N == leaflet zoom -N
  const MIN_ZOOM   = -6;  // zoomOut 6
  const MAX_ZOOM   =  2;  // zoom-in a bit (still uses zoomOut 0 tiles)
  const START_ZOOM = -6;

  // OPTIONAL: where to start the camera in block coords
  // (set this to your "center of interest" — NOT a hard bound)
  const START_BLOCK_X = 0;
  const START_BLOCK_Z = 0;

  const BLANK = "data:image/gif;base64,R0lGODlhAQABAAAAACw=";

  /* ================= HELPERS ================= */

  function withSlash(s){ return s.endsWith("/") ? s : (s + "/"); }
  const BASE = withSlash(BASE_URL);

  // floor division that behaves for negatives (critical for dynmap buckets)
  function floorDiv(n, d){
    if(n >= 0) return Math.floor(n/d);
    const q = Math.trunc(n/d);
    return (q*d === n) ? q : (q - 1);
  }

  function zoomOutFromLeafletZ(z){
    return z < 0 ? -z : 0; // zoom in uses base tiles
  }

  function prefixForZoomOut(zoomOut){
    return zoomOut <= 0 ? "" : ("z".repeat(zoomOut) + "_");
  }

  function bucketForTile(t){
    return floorDiv(t, TILES_PER_DIR);
  }

  // probe one tile to detect ext + pixel size
  function probe(url, timeoutMs=6000){
    return new Promise((resolve)=>{
      const img = new Image();
      const t = setTimeout(()=>{ img.src=""; resolve(false); }, timeoutMs);
      img.onload  = ()=>{ clearTimeout(t); resolve(true); };
      img.onerror = ()=>{ clearTimeout(t); resolve(false); };
      img.src = url + "?p=" + Date.now();
    });
  }

  async function detectTileFormat(){
    const statusEl = document.getElementById("status");
    const status = (m, color="#1565c0") => { statusEl.textContent = m; statusEl.style.background = color; };

    // pick a commonly-existing tile near origin at zoomOut0
    const testTx = 0, testTy = 0;
    const bx = bucketForTile(testTx), by = bucketForTile(testTy);
    const basePath = `tiles/${WORLD}/${VIEW}/${bx}_${by}/${testTx}_${testTy}`;

    for (const ext of ["jpg","png","jpeg"]) {
      const url = BASE + basePath + "." + ext;
      status(`probing:\n${url}`);

      // eslint-disable-next-line no-await-in-loop
      if (await probe(url)) {
        const TILE_PX = await new Promise((resolve)=>{
          const img = new Image();
          img.onload = ()=> resolve(img.naturalWidth || 128);
          img.onerror = ()=> resolve(128);
          img.src = url + "&s=" + Date.now();
        });

        status(`OK\nworld:${WORLD}\nview:${VIEW}\next:.${ext}\ntile:${TILE_PX}px`, "#2e7d32");
        return { EXT: ext, TILE_PX };
      }
    }

    status(
      `FAILED\nNo tiles found at origin.\nIf your map isn't near (0,0), change START_BLOCK_X/Z and/or probe coords in code.`,
      "#b71c1c"
    );
    throw new Error("No tiles found");
  }

  (async () => {
    const { EXT, TILE_PX } = await detectTileFormat();

    // conversion between pixels (zoom 0) and blocks
    const pxPerBlock = TILE_PX / BASE_BLOCKS_PER_TILE;

    const map = L.map("map", {
      crs: L.CRS.Simple,
      minZoom: MIN_ZOOM,
      maxZoom: MAX_ZOOM,
      zoomSnap: 1,
      zoomControl: true
    });

    /**
     * We use a GridLayer so we can compute Dynmap tile coords ourselves.
     * NO coordinate limiting: we always return a URL, and missing tiles fall back to BLANK.
     */
    const DynmapGrid = L.GridLayer.extend({
      createTile: function(coords, done){
        const tile = document.createElement("img");
        tile.alt = "";
        tile.setAttribute("role", "presentation");
        tile.style.width = tile.style.height = TILE_PX + "px";

        // pick dynmap zoomOut from leaflet zoom
        const leafletZ = coords.z;
        const zoomOut = zoomOutFromLeafletZ(leafletZ);
        const blocksPerTile = BASE_BLOCKS_PER_TILE * (1 << zoomOut);
        const pfx = prefixForZoomOut(zoomOut);

        /**
         * Convert this Leaflet tile (coords.x, coords.y at coords.z)
         * into *zoom0 pixel space*, then into blocks, then dynmap tile indices.
         *
         * CRS.Simple:
         *  - x increases right
         *  - y increases down
         * We treat y as Minecraft Z.
         */
        const scaleToZ0 = Math.pow(2, -leafletZ); // z=-6 => 64x bigger in z0 pixels

        const px0_x = coords.x * TILE_PX * scaleToZ0;
        const px0_y = coords.y * TILE_PX * scaleToZ0;

        const blockX = px0_x / pxPerBlock;
        const blockZ = px0_y / pxPerBlock;

        const tx = floorDiv(blockX, blocksPerTile);
        const ty = floorDiv(blockZ, blocksPerTile);

        const bx = bucketForTile(tx);
        const by = bucketForTile(ty);

        const url =
          `${BASE}tiles/${WORLD}/${VIEW}/${bx}_${by}/${pfx}${tx}_${ty}.${EXT}`;

        tile.onload = () => done(null, tile);
        tile.onerror = () => {
          // missing/404 tiles -> show blank
          tile.src = BLANK;
          done(null, tile);
        };

        // cache-bust while testing
        tile.src = url + `?v=${Date.now()}`;

        return tile;
      }
    });

    DynmapGrid.prototype.getAttribution = () => "";
    const layer = new DynmapGrid({ tileSize: TILE_PX }).addTo(map);

    // start view at your chosen block coord, but allow panning infinitely
    const startPxX = START_BLOCK_X * pxPerBlock;
    const startPxY = START_BLOCK_Z * pxPerBlock;
    map.setView([startPxY, startPxX], START_ZOOM);

    // HUD
    const hud = document.getElementById("hud");
    function updateHUD(latlng){
      const z = map.getZoom();
      const zoomOut = zoomOutFromLeafletZ(z);

      // convert latlng->px0->blocks
      const p = map.project(latlng, z);
      const px0x = p.x * Math.pow(2, -z);
      const px0y = p.y * Math.pow(2, -z);

      const X = px0x / pxPerBlock;
      const Z = px0y / pxPerBlock;

      hud.innerHTML =
        `X:<b>${X.toFixed(1)}</b> Z:<b>${Z.toFixed(1)}</b>` +
        ` | leaflet z=${z}` +
        ` | zoomOut:<b>${zoomOut}</b>`;

      return { X, Z };
    }

    map.on("mousemove", e => updateHUD(e.latlng));
    map.on("click", e => {
      const { X, Z } = updateHUD(e.latlng);
      navigator.clipboard?.writeText(`${Math.floor(X)} ${Math.floor(Z)}`);
    });

    console.log("Viewer ready", { WORLD, VIEW, EXT, TILE_PX });
  })();
  </script>
</body>
</html>
