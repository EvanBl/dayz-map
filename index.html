/**
     * Dynmap-style zoom layer:
     * Leaflet zoom 0 = dynmap z0 (most zoomed in)
     * Leaflet zoom 5 = dynmap z5 (most zoomed out)
     */
    const DynmapLayer = L.TileLayer.extend({
      getTileUrl: function (coords) {
        const dynmapZoom = this._tileZoom;
        
        // At dynmap z0 (leaflet 0): tiles at full z0 resolution (1:1)
        // At dynmap z1 (leaflet 1): each tile covers 2x2 z0 area
        // At dynmap z2 (leaflet 2): each tile covers 4x4 z0 area
        // At dynmap z5 (leaflet 5): each tile covers 32x32 z0 area
        
        // Scale factor: at z1 we need 1/2 as many tiles, at z2 we need 1/4, etc.
        const scale = Math.pow(2, dynmapZoom);
        
        // Map leaflet tile coords to dynmap tile indices at this zoom
        const tx = MIN_TX + Math.floor(coords.x / scale);
        const ty = MAX_TY - Math.floor(coords.y / scale);

        if (tx < MIN_TX || tx > MAX_TX || ty < MIN_TY || ty > MAX_TY) return BLANK;

        const bx = bucket(tx), by = bucket(ty);
        // Request from the appropriate dynmap zoom folder
        const folder = dynmapZoom === 0 ? VIEW : `${VIEW}_${dynmapZoom}`;
        return `${BASE}tiles/${WORLD}/${folder}/${bx}_${by}/${tx}_${ty}.${EXT}?v=1`;
      }
    });

    new DynmapLayer("", {
      tileSize: TILE_PX,
      noWrap: true,
      keepBuffer: 10,
      updateWhenIdle: true,
      errorTileUrl: BLANK
    }).addTo(map);<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DayZ World Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- disable caching while testing -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height:100%; margin:0; padding:0; }
    .leaflet-container { background:#0b0f14; }

    #hud, #status {
      position: fixed;
      left: 10px;
      z-index: 9999;
      padding: 6px 10px;
      border-radius: 8px;
      color: #fff;
      font: 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      pointer-events: none;
      background: rgba(0,0,0,.6);
      max-width: 85vw;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #status { top: 10px; font: 14px system-ui, sans-serif; background:#1565c0; }
    #hud { bottom: 10px; }
    #hud b { color:#8bc34a; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="status">booting…</div>
  <div id="hud">loading…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
  /* ================= CONFIG ================= */

  const WORLD = "world";
  const VIEW  = "ne"; // dynmap prefix
  const BASE_URL = "https://pub-83eb0b1759804463a95053e4b8319ef5.r2.dev/";

  // your dynmap setup
  const BLOCKS_PER_TILE = 32;
  const TILES_PER_DIR   = 32;

  // rendered bounds (blocks)
  const X_MIN = -2640, X_MAX = 2720;
  const Z_MIN = -2720, Z_MAX = 5536;

  // We have 6 dynmap zoom levels (z0 to z5)
  // z0 = most zoomed IN, z5 = most zoomed OUT
  // Map directly: Leaflet zoom 0 = z0, zoom 5 = z5
  const MIN_ZOOM   = 0;   // = dynmap z0 (most zoomed in)
  const MAX_ZOOM   = 5;   // = dynmap z5 (most zoomed out)
  const START_ZOOM = 5;   // start at most zoomed out view

  const BLANK = "data:image/gif;base64,R0lGODlhAQABAAAAACw=";

  /* ================= HELPERS ================= */
  function floorDiv(n, d){
    if(n >= 0) return Math.floor(n/d);
    const q = Math.trunc(n/d);
    return (q*d === n) ? q : (q - 1);
  }
  const tileX  = (x) => floorDiv(x, BLOCKS_PER_TILE);
  const tileY  = (z) => floorDiv(z, BLOCKS_PER_TILE);
  const bucket = (t) => floorDiv(t, TILES_PER_DIR);

  function withSlash(s){ return s.endsWith("/") ? s : (s + "/"); }
  const BASE = withSlash(BASE_URL);

  // probe a likely tile
  const PROBE_TX = tileX(-16);
  const PROBE_TY = tileY(-16);

  function tilePath(ext, tx, ty){
    const bx = bucket(tx), by = bucket(ty);
    return `tiles/${WORLD}/${VIEW}/${bx}_${by}/${tx}_${ty}.${ext}`;
  }

  function probe(url, timeoutMs=6000){
    return new Promise((resolve)=>{
      const img = new Image();
      const t = setTimeout(()=>{ img.src=""; resolve(false); }, timeoutMs);
      img.onload  = ()=>{ clearTimeout(t); resolve(true); };
      img.onerror = ()=>{ clearTimeout(t); resolve(false); };
      img.src = url + "?p=" + Date.now();
    });
  }

  async function detect(){
    const statusEl = document.getElementById("status");
    const status = (m, color="#1565c0") => { statusEl.textContent = m; statusEl.style.background = color; };

    for (const ext of ["jpg","png","jpeg"]) {
      const url = BASE + tilePath(ext, PROBE_TX, PROBE_TY);
      status(`probing:\n${url}`);

      // eslint-disable-next-line no-await-in-loop
      if (await probe(url)) {
        const TILE_PX = await new Promise((resolve)=>{
          const img = new Image();
          img.onload = ()=> resolve(img.naturalWidth || 128);
          img.onerror = ()=> resolve(128);
          img.src = url + "&s=" + Date.now();
        });

        status(`OK\nworld:${WORLD}\nview:${VIEW}\next:.${ext}\ntile:${TILE_PX}px`, "#2e7d32");
        return { EXT: ext, TILE_PX };
      }
    }

    status(`FAILED\nNo tiles found.\nCheck:\n- public read\n- /tiles/${WORLD}/${VIEW}/...\n- upload finished`, "#b71c1c");
    throw new Error("No tiles found");
  }

  (async () => {
    const { EXT, TILE_PX } = await detect();

    // tile-index bounds at z0
    const MIN_TX = tileX(X_MIN);
    const MAX_TX = tileX(X_MAX - 1);
    const MIN_TY = tileY(Z_MIN);
    const MAX_TY = tileY(Z_MAX - 1);

    const W = (MAX_TX - MIN_TX + 1);
    const H = (MAX_TY - MIN_TY + 1);

    // z0 pixel bounds (render rectangle)
    const z0Bounds = L.latLngBounds(
      [-(H * TILE_PX), 0],
      [0, (W * TILE_PX)]
    );

    const map = L.map("map", {
      crs: L.CRS.Simple,
      minZoom: MIN_ZOOM,
      maxZoom: MAX_ZOOM,
      zoomSnap: 1,
      updateWhenZooming: false,
      zoomControl: true
    });

    /**
     * Dynmap-style zoom layer:
     * Leaflet zoom 0 = dynmap z5 (most zoomed out)
     * Leaflet zoom 5 = dynmap z0 (most zoomed in)
     */
    const DynmapLayer = L.TileLayer.extend({
      getTileUrl: function (coords) {
        const leafletZoom = this._tileZoom;
        // Convert: Leaflet 0->5 to Dynmap z5->z0
        const dynmapZoom = (MAX_ZOOM - leafletZoom);
        
        // At dynmap z0 (leaflet 5): full detail z0 tiles
        // At dynmap z1 (leaflet 4): each tile covers 2x2 z0 tiles
        // At dynmap z2 (leaflet 3): each tile covers 4x4 z0 tiles, etc.
        
        // Scale factor: how many z0 tiles does one tile at this zoom cover?
        const scale = Math.pow(2, dynmapZoom);
        
        // Map leaflet tile coords to z0 tile indices
        const tx = MIN_TX + (coords.x * scale);
        const ty = MAX_TY - (coords.y * scale);

        if (tx < MIN_TX || tx > MAX_TX || ty < MIN_TY || ty > MAX_TY) return BLANK;

        const bx = bucket(tx), by = bucket(ty);
        // Request from the appropriate dynmap zoom folder
        return `${BASE}tiles/${WORLD}/${VIEW}_${dynmapZoom}/${bx}_${by}/${tx}_${ty}.${EXT}?v=1`;
      }
    });

    new DynmapLayer("", {
      tileSize: TILE_PX,
      noWrap: true,
      keepBuffer: 10,
      updateWhenIdle: true,
      errorTileUrl: BLANK
    }).addTo(map);

    // Center on the rendered rectangle and START at most zoomed out
    map.fitBounds(z0Bounds.pad(0.12));
    map.setZoom(START_ZOOM);

    // HUD
    const hud = document.getElementById("hud");
    const pxPerBlock = TILE_PX / BLOCKS_PER_TILE;

    function updateHUD(latlng){
      const dynmapZ = map.getZoom();

      const p = map.project(latlng, dynmapZ);
      const scale = Math.pow(2, dynmapZ);
      const px0 = p.x * scale;
      const py0 = p.y * scale;

      const X = (px0 / pxPerBlock) + (MIN_TX * BLOCKS_PER_TILE);
      const Z = (py0 / pxPerBlock) + (MIN_TY * BLOCKS_PER_TILE);

      const tx = MIN_TX + Math.floor(px0 / TILE_PX);
      const ty = MAX_TY - Math.floor(py0 / TILE_PX);

      hud.innerHTML =
        `X:<b>${X.toFixed(1)}</b> Z:<b>${Z.toFixed(1)}</b>` +
        ` | tile:<b>${tx}_${ty}</b>` +
        ` | dynmap z<b>${dynmapZ}</b>`;

      return { X, Z };
    }

    map.on("mousemove", e => updateHUD(e.latlng));
    map.on("click", e => {
      const { X, Z } = updateHUD(e.latlng);
      navigator.clipboard?.writeText(`${Math.floor(X)} ${Math.floor(Z)}`);
    });

    console.log("Viewer ready", { WORLD, VIEW, EXT, TILE_PX });
  })();
  </script>
</body>
</html>
