<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DayZ World Map (Dynmap z0 minimal)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height:100%; margin:0; padding:0; }
    .leaflet-container { background:#0b0f14; }

    #status, #hud {
      position: fixed;
      left: 10px;
      z-index: 9999;
      padding: 8px 10px;
      border-radius: 10px;
      color: #fff;
      font: 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      pointer-events: none;
      background: rgba(0,0,0,.65);
      max-width: 85vw;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #status { top: 10px; background:#1565c0; }
    #hud { bottom: 10px; }
    #hud b { color:#8bc34a; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="status">booting…</div>
  <div id="hud">loading…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
  /* ================= CONFIG (BASE z0 ONLY) ================= */

  // Dynmap folder structure:
  // {BASE}/tiles/{WORLD}/{VIEW}/{bx_by}/{tx_ty}.jpg
  const WORLD   = "world";
  const VIEW    = "ne";
  const BASE_URL = "https://pub-83eb0b1759804463a95053e4b8319ef5.r2.dev/";

  // confirmed from your overlay
  const EXT = "jpg";
  const TILE_PX = 128;

  // dynmap buckets: 32 tiles per dir
  const TILES_PER_DIR = 32;

  // If the entire world is mirrored, flip here.
  // Start with BOTH false.
  const FLIP_X = false;
  const FLIP_Y = false;

  // Probe/search settings (find a real tile to start on)
  const PROBE_MAX_RADIUS = 256;   // tiles
  const PROBE_TIMEOUT_MS = 2500;

  // blank fallback if tile 404s
  const BLANK = "data:image/gif;base64,R0lGODlhAQABAAAAACw=";

  /* ================= HELPERS ================= */

  function withSlash(s){ return s.endsWith("/") ? s : (s + "/"); }
  const BASE = withSlash(BASE_URL);

  function floorDiv(n, d){
    if (n >= 0) return Math.floor(n / d);
    const q = Math.trunc(n / d);
    return (q * d === n) ? q : (q - 1);
  }

  function bucket(t){ return floorDiv(t, TILES_PER_DIR); }

  function tileUrl(tx, ty){
    const bx = bucket(tx);
    const by = bucket(ty);
    return `${BASE}tiles/${WORLD}/${VIEW}/${bx}_${by}/${tx}_${ty}.${EXT}`;
  }

  function probeImage(url, timeoutMs){
    return new Promise((resolve) => {
      const img = new Image();
      const t = setTimeout(() => { img.src = ""; resolve(false); }, timeoutMs);
      img.onload = () => { clearTimeout(t); resolve(true); };
      img.onerror = () => { clearTimeout(t); resolve(false); };
      img.src = url + "?p=" + Date.now();
    });
  }

  // Spiral offsets (0,0) then outward
  function* spiral(maxR){
    yield [0,0];
    for (let r = 1; r <= maxR; r++){
      // top edge (left->right)
      for (let x = -r; x <= r; x++) yield [x, -r];
      // right edge (top->bottom)
      for (let y = -r + 1; y <= r; y++) yield [r, y];
      // bottom edge (right->left)
      for (let x = r - 1; x >= -r; x--) yield [x, r];
      // left edge (bottom->top)
      for (let y = r - 1; y >= -r + 1; y--) yield [-r, y];
    }
  }

  async function findStartTile(){
    const statusEl = document.getElementById("status");
    const setStatus = (msg, color="#1565c0") => { statusEl.textContent = msg; statusEl.style.background = color; };

    setStatus("probing for a real tile near (0,0)…");

    for (const [dx, dy] of spiral(PROBE_MAX_RADIUS)){
      const tx = dx;
      const ty = dy;
      const url = tileUrl(tx, ty);
      // eslint-disable-next-line no-await-in-loop
      const ok = await probeImage(url, PROBE_TIMEOUT_MS);
      if (ok){
        setStatus(`OK\nworld:${WORLD}\nview:${VIEW}\next:${EXT}\ntile:${TILE_PX}px\nstartTile:${tx}_${ty}`, "#2e7d32");
        return { tx, ty };
      }
    }

    setStatus(`FAILED\nNo tiles found near origin.\nCheck BASE_URL / public access / path.`, "#b71c1c");
    throw new Error("No tiles found in probe radius");
  }

  /* ================= MAP ================= */

  const map = L.map("map", {
    crs: L.CRS.Simple,
    minZoom: 0,
    maxZoom: 0,
    zoomSnap: 1,
    zoomControl: true,
    inertia: true
  });

  // IMPORTANT:
  // We intentionally use GridLayer so Leaflet gives us tile coords (x,y) at z=0.
  // We treat those as Dynmap tile coords (tx,ty). No “world block math” here.
  const DynZ0 = L.GridLayer.extend({
    createTile: function(coords){
      const img = document.createElement("img");
      img.width = TILE_PX;
      img.height = TILE_PX;
      img.alt = `${coords.x}_${coords.y}`;

      // Leaflet y grows downward. Dynmap tile grid also grows “down” in image space,
      // but if your whole map is upside-down you can toggle FLIP_Y.
      let tx = coords.x;
      let ty = coords.y;
      if (FLIP_X) tx = -tx - 1;
      if (FLIP_Y) ty = -ty - 1;

      img.src = tileUrl(tx, ty);
      img.onerror = () => { img.src = BLANK; };
      return img;
    }
  });

  new DynZ0({
    tileSize: TILE_PX,
    keepBuffer: 8,
    updateWhenIdle: true,
    updateWhenZooming: false
  }).addTo(map);

  // Coordinate system: latlng units == pixels.
  // So “tile (tx,ty)” is the pixel point (tx*TILE_PX, ty*TILE_PX).
  function tileToLatLng(tx, ty){
    const xPx = tx * TILE_PX;
    const yPx = ty * TILE_PX;
    return L.latLng(yPx + TILE_PX/2, xPx + TILE_PX/2);
  }

  const hud = document.getElementById("hud");

  function updateHUD(latlng){
    const xPx = latlng.lng;
    const yPx = latlng.lat;
    const tx = Math.floor(xPx / TILE_PX);
    const ty = Math.floor(yPx / TILE_PX);
    hud.innerHTML =
      `px x:<b>${xPx.toFixed(1)}</b> y:<b>${yPx.toFixed(1)}</b>` +
      ` | tile:<b>${tx}_${ty}</b>` +
      ` | z0 only`;
  }

  map.on("mousemove", e => updateHUD(e.latlng));
  map.on("click", e => {
    updateHUD(e.latlng);
    const tx = Math.floor(e.latlng.lng / TILE_PX);
    const ty = Math.floor(e.latlng.lat / TILE_PX);
    navigator.clipboard?.writeText(`${tx} ${ty}`);
  });

  (async () => {
    const { tx, ty } = await findStartTile();
    map.setView(tileToLatLng(tx, ty), 0);
    updateHUD(map.getCenter());
  })();
  </script>
</body>
</html>
