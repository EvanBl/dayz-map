<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DayZ World Map v13e</title>

  <!-- kill caching -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    .leaflet-container { background: #0b0f14; }
    #badge, #status {
      position: fixed; left: 10px; z-index: 9999;
      padding: 6px 10px; border-radius: 8px; font: 14px system-ui, sans-serif; color: #fff;
    }
    #badge  { top: 10px;  background: #2e7d32; }
    #status { top: 44px; background: #1565c0; max-width: 80vw; word-break: break-all; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="badge">v13e • FLOOR • Y-fixed</div>
  <div id="status">booting…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // ---------------- CONFIG (match your folders) ----------------
    const GX_MIN = -3, GX_MAX =  2;   // bucket folders present (X)
    const GY_MIN = -6, GY_MAX =  6;   // bucket folders present (Y)

    const WORLD  = "world";
    const VIEW   = "flat";            // change if you use "surface" or isometric
    const EXT    = "jpg";
    const BUCKET = 32;
    const VERSION = "v13e";

    // Known-good tile from your tree
    const START_X = -10;
    const START_Y = -33;

    // ---------------- DERIVED LIMITS ----------------
    const MIN_X = GX_MIN * BUCKET;
    const MAX_X = GX_MAX * BUCKET + (BUCKET - 1);
    const MIN_Y = GY_MIN * BUCKET;
    const MAX_Y = GY_MAX * BUCKET + (BUCKET - 1);

    const widthTiles  = MAX_X - MIN_X + 1;
    const heightTiles = MAX_Y - MIN_Y + 1;

    // 1×1 transparent data URI (used for clamping instead of 404s)
    const BLANK = 'data:image/gif;base64,R0lGODlhAQABAAAAACw=';

    // ---------------- HELPERS ----------------
    // FLOOR division that behaves for negatives
    function floorDiv(n, d) {
      if (n >= 0) return Math.floor(n / d);
      const q = Math.trunc(n / d);          // toward 0
      return (q * d === n) ? q : q - 1;     // step more negative if remainder
    }
    const group = (n) => floorDiv(n, BUCKET);

    // Base URL built from where THIS file lives (works in root or /docs)
    const BASE = (location.origin + location.pathname).replace(/[^/]*$/, '');

    // Auto-detect actual TILE size (128/256/512) from the start tile
    function detectTileSize(url){
      return new Promise((resolve) => {
        const img = new Image();
        img.onload  = () => resolve(img.naturalWidth || 128);
        img.onerror = () => resolve(128);
        img.src = url + "?probe=" + VERSION;
      });
    }

    // CRS.Simple math helpers
    // Leaflet tile index -> **file** coordinates:
    // X increases to the right (same), but FILE Y must **DESCEND** as Leaflet's row increases.
    const fileX = (lx) => MIN_X + lx;
    const fileY = (ly) => MAX_Y - ly;    // <-- Y FIX (descend)

    // Use viewport to choose a safe min zoom (prevents full-black backgrounds)
    function computeSafeMinZoom(tilePx) {
      const worldPxW = widthTiles * tilePx;
      const worldPxH = heightTiles * tilePx;
      const need = Math.max(worldPxW / innerWidth, worldPxH / innerHeight);
      let z = 0;
      while ((1 << (-z)) < need && z > -8) z--;  // cap to -8
      return z;
    }

    // ---------------- BOOT ----------------
    (async () => {
      const startFolder = `${group(START_X)}_${group(START_Y)}`;
      const startURL = `${BASE}tiles/${WORLD}/${VIEW}/${startFolder}/${START_X}_${START_Y}.${EXT}`;
      const TILE = await detectTileSize(startURL);

      // Status pill
      const status = (msg, color='#1565c0') => {
        const el = document.getElementById('status');
        el.textContent = msg;
        el.style.background = color;
      };
      status(`BASE ok • view=${VIEW} • tile=${TILE}px\nstart: ${startURL}`, '#2e7d32');

      // Custom tile layer (clamps outside our index range; no 404 blackout)
      const DynmapLayer = L.TileLayer.extend({
        getTileUrl: function (coords) {
          const fx = fileX(coords.x);
          const fy = fileY(coords.y);            // <-- Y FIX used here
          if (fx < MIN_X || fx > MAX_X || fy < MIN_Y || fy > MAX_Y) return BLANK;
          const gx = group(fx);
          const gy = group(fy);
          return `${BASE}tiles/${WORLD}/${VIEW}/${gx}_${gy}/${fx}_${fy}.${EXT}?${VERSION}`;
        }
      });

      // Map init
      const map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: 0, maxZoom: 2,
        zoomSnap: 1, wheelPxPerZoomLevel: 80,
        updateWhenZooming: false,
        zoomControl: true
      });

      // Prevent zooming farther out than the world can fill
      map.setMinZoom(computeSafeMinZoom(TILE));

      const layer = new DynmapLayer('', {
        tileSize: TILE,
        noWrap: true,
        minNativeZoom: 0,
        maxNativeZoom: 0,
        keepBuffer: 4
      }).addTo(map);

      // Center on START tile
      const startLeafletX = START_X - MIN_X;    // column offset
      const startLeafletY = MAX_Y - START_Y;    // <-- Y FIX for row offset
      const startLat = -(startLeafletY * TILE); // CRS.Simple: top is negative
      const startLng =  (startLeafletX * TILE);
      map.setView([startLat, startLng], -1);

      // Bounds (top negative, bottom 0)
      const bounds = [[-(heightTiles * TILE), 0], [0, widthTiles * TILE]];
      map.setMaxBounds(bounds);
      map.options.maxBoundsViscosity = 1.0;

      // Transparent tile for any holes; log real misses
      L.TileLayer.prototype.options.errorTileUrl = BLANK;
      layer.on('tileerror', e => console.warn('404 tile inside range:', e.tile.src));

      // Debug to console
      console.log('Viewer', { BASE, VIEW, TILE, START_X, START_Y, MIN_X, MAX_X, MIN_Y, MAX_Y });
      console.log('Start URL (should exist):',
        `${BASE}tiles/${WORLD}/${VIEW}/${group(START_X)}_${group(START_Y)}/${START_X}_${START_Y}.${EXT}?${VERSION}`
      );
    })();
  </script>
</body>
</html>
