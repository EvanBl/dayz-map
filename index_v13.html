<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DayZ World Map v13d</title>

  <!-- kill caching -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    .leaflet-container { background: #0b0f14; }
    #badge, #status {
      position: fixed; left: 10px; z-index: 9999;
      padding: 6px 10px; border-radius: 8px; font: 14px system-ui, sans-serif; color: #fff;
    }
    #badge  { top: 10px;  background: #2e7d32; }
    #status { top: 44px; background: #1565c0; max-width: 80vw; word-break: break-all; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="badge">v13d • FLOOR • auto-view</div>
  <div id="status">booting…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // ---------- EDIT THESE 4 TO MATCH YOUR FOLDER RANGE ----------
    const GX_MIN = -3, GX_MAX =  2;   // bucket folders you have (X)
    const GY_MIN = -6, GY_MAX =  6;   // bucket folders you have (Y)

    // A real existing tile you know (from your tree screenshots)
    const START_X = -10;
    const START_Y = -33;

    // ---------- CONSTANTS ----------
    const EXT    = "jpg";
    const TILE   = 128;
    const BUCKET = 32;
    const VERSION = "v13d";

    // Likely view folder names (order matters). We'll probe them.
    const VIEW_CANDIDATES = [
      "flat",                 // default top-down
      "surface",              // common custom name
      "iso_SE_30_hires",      // your worlds.txt perspective
      "iso_SE_30",
      "isometric",
    ];

    const MIN_X = GX_MIN * BUCKET;
    const MAX_X = GX_MAX * BUCKET + (BUCKET - 1);
    const MIN_Y = GY_MIN * BUCKET;
    const MAX_Y = GY_MAX * BUCKET + (BUCKET - 1);

    const widthTiles  = MAX_X - MIN_X + 1;
    const heightTiles = MAX_Y - MIN_Y + 1;

    const BLANK = 'data:image/gif;base64,R0lGODlhAQABAAAAACw=';

    // Helpers
    const fileX = (lx) => MIN_X + lx;
    const fileY = (ly) => MIN_Y + ly;

    function floorDiv(n, d) {
      if (n >= 0) return Math.floor(n / d);
      const q = Math.trunc(n / d);      // toward 0
      return (q * d === n) ? q : q - 1; // step more negative if remainder
    }
    const group = (n) => floorDiv(n, BUCKET);

    const status = (msg, color='#1565c0') => {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.style.background = color;
    };
    const withSlash = s => s.endsWith('/') ? s : s + '/';

    // Build 2 base candidates: where this file is, and the hard repo root
    const locationBase = withSlash(location.origin + location.pathname.replace(/[^/]*$/, ''));
    const hardBase     = 'https://evanbl.github.io/dayz-map/';

    const folderXY = `${group(START_X)}_${group(START_Y)}`;
    const makePath = (view) => `tiles/world/${view}/${folderXY}/${START_X}_${START_Y}.${EXT}?${VERSION}`;

    function probe(url, timeoutMs=6000) {
      return new Promise((resolve) => {
        const img = new Image();
        const timer = setTimeout(() => { img.src=''; resolve(false); }, timeoutMs);
        img.onload = () => { clearTimeout(timer); resolve(true); };
        img.onerror = () => { clearTimeout(timer); resolve(false); };
        img.src = url;
      });
    }

    async function resolveBaseAndView() {
      const bases = [withSlash(locationBase), withSlash(hardBase)];
      for (const base of bases) {
        for (const view of VIEW_CANDIDATES) {
          const url = base + makePath(view);
          status(`probing:\n${url}`);
          // eslint-disable-next-line no-await-in-loop
          if (await probe(url)) {
            status(`OK → base: ${base}\nview: ${view}\nstart: ${url}`, '#2e7d32');
            return { base, view };
          }
        }
      }
      status(
        `No start tile found.\nTried bases:\n- ${withSlash(locationBase)}\n- ${withSlash(hardBase)}\n`+
        `and views: ${VIEW_CANDIDATES.join(', ')}\n\n`+
        `Check your repo: tiles/world/<view>/<gx>_<gy>/${START_X}_${START_Y}.${EXT}`,
        '#b71c1c'
      );
      throw new Error('Could not resolve base/view');
    }

    function computeSafeMinZoom() {
      const worldPxW = widthTiles * TILE;
      const worldPxH = heightTiles * TILE;
      const needFactor = Math.max(worldPxW / window.innerWidth, worldPxH / window.innerHeight);
      let z = 0;
      while ((1 << (-z)) < needFactor && z > -8) z--;  // cap to -8
      return z;
    }

    (async () => {
      try {
        const { base: BASE, view: VIEW } = await resolveBaseAndView();

        // Tile layer that clamps out-of-range requests (no blackouts)
        const DynmapLayer = L.TileLayer.extend({
          getTileUrl: function (coords) {
            const fx = fileX(coords.x);
            const fy = fileY(coords.y);
            if (fx < MIN_X || fx > MAX_X || fy < MIN_Y || fy > MAX_Y) return BLANK;
            const gx = group(fx);
            const gy = group(fy);
            return `${BASE}tiles/world/${VIEW}/${gx}_${gy}/${fx}_${fy}.${EXT}?${VERSION}`;
          }
        });

        const map = L.map('map', {
          crs: L.CRS.Simple,
          minZoom: 0, maxZoom: 2,
          zoomSnap: 1, wheelPxPerZoomLevel: 80,
          updateWhenZooming: false,
          zoomControl: true
        });

        // Safe zoom-out so you don't zoom into "all black"
        const safeMin = computeSafeMinZoom();
        map.setMinZoom(safeMin);

        const layer = new DynmapLayer('', {
          tileSize: TILE,
          noWrap: true,
          minNativeZoom: 0,
          maxNativeZoom: 0,
          keepBuffer: 4
        }).addTo(map);

        // CRS.Simple: invert Y when converting to lat
        const startLeafletX = START_X - MIN_X;
        const startLeafletY = START_Y - MIN_Y;
        const startLat = -(startLeafletY * TILE);
        const startLng =  (startLeafletX * TILE);
        map.setView([startLat, startLng], Math.max(-1, safeMin));

        // Bounds (top negative, bottom 0)
        const bounds = [[-(heightTiles * TILE), 0], [0, widthTiles * TILE]];
        map.setMaxBounds(bounds);
        map.options.maxBoundsViscosity = 1.0;

        // Log 404s if any single tile is missing inside the valid range
        layer.on('tileerror', e => console.warn('404 tile:', e.tile.src));

        console.log('Resolved', { BASE, VIEW, START_X, START_Y, folderXY, GX_MIN, GX_MAX, GY_MIN, GY_MAX });

      } catch (e) {
        console.error(e);
      }
    })();
  </script>
</body>
</html>
