<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DayZ World Map v13b</title>

  <!-- kill caching -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    .leaflet-container { background: #0b0f14; }
    #badge, #status {
      position: fixed; left: 10px; z-index: 9999;
      padding: 6px 10px; border-radius: 8px; font: 14px system-ui, sans-serif; color: #fff;
    }
    #badge  { top: 10px;  background: #2e7d32; }
    #status { top: 44px; background: #1565c0; max-width: 70vw; word-break: break-all; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="badge">v13b • bucket=32 • FLOOR</div>
  <div id="status">resolving base…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // ---------- CONFIG: match your repo ----------
    const GX_MIN = -3, GX_MAX =  2;   // existing folders
    const GY_MIN = -6, GY_MAX =  6;

    const START_X = -10;              // real, existing tile
    const START_Y = -33;

    // ---------- CONSTANTS ----------
    const WORLD  = "world";
    const VIEW   = "flat";
    const EXT    = "jpg";
    const TILE   = 128;
    const BUCKET = 32;
    const VERSION = "v13b";           // cache-bust

    const MIN_X = GX_MIN * BUCKET;
    const MAX_X = GX_MAX * BUCKET + (BUCKET - 1);
    const MIN_Y = GY_MIN * BUCKET;
    const MAX_Y = GY_MAX * BUCKET + (BUCKET - 1);

    const widthTiles  = MAX_X - MIN_X + 1;
    const heightTiles = MAX_Y - MIN_Y + 1;

    // Map Leaflet tile index -> file coords
    const fileX = (lx) => MIN_X + lx;
    const fileY = (ly) => MIN_Y + ly;

    // --------- SAFE FLOOR DIVISION for negatives ----------
    function floorDiv(n, d) {
      if (n >= 0) return Math.floor(n / d);
      const q = Math.trunc(n / d);        // toward 0
      return (q * d === n) ? q : q - 1;   // step more negative if remainder
    }
    const group = (n) => floorDiv(n, BUCKET);  // FLOOR bucketing

    // --------- Resolve the correct BASE automatically ----------
    function withSlash(s){ return s.endsWith('/') ? s : s + '/'; }

    const locationBase = withSlash(location.origin + location.pathname.replace(/[^/]*$/, ''));
    const hardBase     = 'https://evanbl.github.io/dayz-map/';

    const startFolder = `${group(START_X)}_${group(START_Y)}`;
    const startPath   = `tiles/${WORLD}/${VIEW}/${startFolder}/${START_X}_${START_Y}.${EXT}?${VERSION}`;

    function probe(url, timeoutMs=5000) {
      return new Promise((resolve) => {
        const img = new Image();
        const timer = setTimeout(() => { img.src=''; resolve(false); }, timeoutMs);
        img.onload = () => { clearTimeout(timer); resolve(true); };
        img.onerror = () => { clearTimeout(timer); resolve(false); };
        img.src = url;
      });
    }

    async function resolveBase() {
      const status = (msg, color='#1565c0') => {
        const el = document.getElementById('status');
        el.textContent = msg;
        el.style.background = color;
      };

      const cand1 = withSlash(locationBase);
      const cand2 = withSlash(hardBase);

      status(`trying base #1 ${cand1} …`);
      if (await probe(cand1 + startPath)) {
        status(`using base: ${cand1}`, '#2e7d32');
        return cand1;
      }

      status(`trying base #2 ${cand2} …`);
      if (await probe(cand2 + startPath)) {
        status(`using base: ${cand2}`, '#2e7d32');
        return cand2;
      }

      status(`couldn't load START tile from either base.
#1 ${cand1 + startPath}
#2 ${cand2 + startPath}`, '#b71c1c');
      throw new Error('No valid base for tiles');
    }

    // --------- Boot the map once base is resolved ----------
    (async () => {
      try {
        const BASE = await resolveBase();

        // Tile layer
        const DynmapLayer = L.TileLayer.extend({
          getTileUrl: function (coords) {
            const fx = fileX(coords.x);
            const fy = fileY(coords.y);
            const gx = group(fx);
            const gy = group(fy);
            return `${BASE}tiles/${WORLD}/${VIEW}/${gx}_${gy}/${fx}_${fy}.${EXT}?${VERSION}`;
          }
        });

        // Map init
        const map = L.map('map', {
          crs: L.CRS.Simple,
          minZoom: -5,
          maxZoom:  2,
          zoomSnap: 1,
          wheelPxPerZoomLevel: 80,
          zoomControl: true,
        });

        const layer = new DynmapLayer('', {
          tileSize: TILE,
          noWrap: true,
          maxNativeZoom: 0
        }).addTo(map);

        // CRS.Simple: invert Y when converting to lat
        const startLeafletX = START_X - MIN_X;
        const startLeafletY = START_Y - MIN_Y;
        const startLat = -(startLeafletY * TILE);
        const startLng =  (startLeafletX * TILE);
        map.setView([startLat, startLng], -1);

        // Bounds (top negative, bottom 0)
        const bounds = [[-(heightTiles * TILE), 0], [0, widthTiles * TILE]];
        map.setMaxBounds(bounds);
        map.options.maxBoundsViscosity = 1.0;

        // Transparent 1x1 for 404 holes
        L.TileLayer.prototype.options.errorTileUrl =
          'data:image/gif;base64,R0lGODlhAQABAAAAACw=';

        // Helpful logs
        console.log("Resolved BASE:", BASE);
        console.log(
          "Start URL:",
          `${BASE}tiles/${WORLD}/${VIEW}/${group(START_X)}_${group(START_Y)}/${START_X}_${START_Y}.${EXT}?${VERSION}`
        );
        layer.on('tileerror', e => console.warn('404 tile:', e.tile.src));

      } catch (e) {
        console.error(e);
      }
    })();
  </script>
</body>
</html>
